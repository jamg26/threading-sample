<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Execution Strategies</title>
    <style>
        body { font-family: system-ui, sans-serif; padding: 20px; max-width: 600px; line-height: 1.5; }
        .control-panel { background: #f0f0f0; padding: 15px; border-radius: 6px; margin-bottom: 20px; }
        select, button { padding: 10px; font-size: 16px; margin-top: 10px; width: 100%; box-sizing: border-box; }
        button { cursor: pointer; background: #0056b3; color: white; border: none; border-radius: 4px; font-weight: bold; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .interactive-area { padding: 15px; border: 2px dashed #ccc; background: #fafafa; display: flex; align-items: center; gap: 15px; }
        input { padding: 8px; flex-grow: 1; font-size: 16px; }
        progress { width: 100%; height: 20px; margin-top: 15px; }
        
        .spinner {
            width: 30px; height: 30px;
            border: 4px solid #ccc;
            border-top-color: #0056b3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <h2>Execution Strategies (10-Second Tests)</h2>

    <div class="interactive-area">
        <div class="spinner"></div>
        <input type="text" placeholder="Type here. If the spinner stops, the UI is blocked.">
    </div>

    <div class="control-panel">
        <label for="strategy-select"><strong>Select Execution Strategy:</strong></label><br>
        <select id="strategy-select">
            <option value="blocking">1. Single-Thread: Synchronous Blocking (10s CPU hang)</option>
            <option value="async">2. Single-Thread: Async Timer (10s wait, no CPU hang)</option>
            <option value="slicing">3. Single-Thread: Time-Slicing (10s CPU work, chunked)</option>
            <option value="worker">4. Multi-Thread: Web Worker (10s CPU work, offloaded)</option>
        </select>
        <br>
        <button id="btn-run">Run 10-Second Task</button>
    </div>

    <div id="status">Status: Ready</div>
    <progress id="progress-bar" value="0" max="100"></progress>

    <script>
        const btnRun = document.getElementById('btn-run');
        const strategySelect = document.getElementById('strategy-select');
        const statusEl = document.getElementById('status');
        const progressBar = document.getElementById('progress-bar');
        
        const TASK_DURATION_MS = 10000; // 10 seconds

        // --- Setup Web Worker via Blob ---
        const workerScript = `
            self.onmessage = function(e) {
                const duration = e.data;
                const start = Date.now();
                let elapsed = 0;
                
                // Process in 100ms chunks to report progress back to the main thread
                while (elapsed < duration) {
                    const chunkStart = Date.now();
                    while (Date.now() - chunkStart < 100) {} // Block worker thread for 100ms
                    
                    elapsed = Date.now() - start;
                    self.postMessage({ progress: (elapsed / duration) * 100 });
                }
                
                self.postMessage({ complete: true });
            };
        `;
        const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
        const worker = new Worker(URL.createObjectURL(workerBlob));

        // --- Execution Controller ---
        btnRun.addEventListener('click', () => {
            const strategy = strategySelect.value;
            
            btnRun.disabled = true;
            progressBar.value = 0;
            statusEl.textContent = 'Status: Processing for 10 seconds...';
            statusEl.style.color = 'orange';

            // Allow UI to paint the reset state before starting work
            setTimeout(() => {
                if (strategy === 'blocking') runBlocking();
                else if (strategy === 'async') runAsyncTimer();
                else if (strategy === 'slicing') runTimeSlicing();
                else if (strategy === 'worker') runWebWorker();
            }, 50);
        });

        function completeTask() {
            progressBar.value = 100;
            statusEl.textContent = 'Status: Completed!';
            statusEl.style.color = 'green';
            btnRun.disabled = false;
        }

        // --- 1. Single-Thread: Synchronous Blocking ---
        function runBlocking() {
            const start = Date.now();
            // Monopolizes Call Stack. Spinner stops. Input freezes.
            while (Date.now() - start < TASK_DURATION_MS) {
                // CPU spins here
            }
            completeTask();
        }

        // --- 2. Single-Thread: Async Timer ---
        function runAsyncTimer() {
            const start = Date.now();
            
            // Updates progress visually, but does no actual CPU math
            const interval = setInterval(() => {
                const elapsed = Date.now() - start;
                progressBar.value = (elapsed / TASK_DURATION_MS) * 100;
                
                if (elapsed >= TASK_DURATION_MS) {
                    clearInterval(interval);
                    completeTask();
                }
            }, 100);
        }

        // --- 3. Single-Thread: Time-Slicing (Chunking) ---
        function runTimeSlicing() {
            const start = Date.now();
            
            function processChunk() {
                const chunkStart = Date.now();
                // Block the main thread for 50ms (simulating heavy math chunk)
                while (Date.now() - chunkStart < 50) {} 
                
                const elapsed = Date.now() - start;
                progressBar.value = (elapsed / TASK_DURATION_MS) * 100;

                if (elapsed < TASK_DURATION_MS) {
                    // Yield to Event Loop so UI can update, then run next chunk
                    setTimeout(processChunk, 0); 
                } else {
                    completeTask();
                }
            }

            processChunk();
        }

        // --- 4. Multi-Thread: Web Worker ---
        function runWebWorker() {
            worker.postMessage(TASK_DURATION_MS);
            
            worker.onmessage = function(e) {
                if (e.data.complete) {
                    completeTask();
                } else {
                    progressBar.value = e.data.progress;
                }
            };
        }
    </script>
</body>
</html>
