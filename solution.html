<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Threading Strategies</title>
    <style>
        body { font-family: system-ui, sans-serif; padding: 20px; max-width: 600px; line-height: 1.5; }
        .control-panel { background: #f0f0f0; padding: 15px; border-radius: 6px; margin-bottom: 20px; }
        select, button { padding: 10px; font-size: 16px; margin-top: 10px; }
        button { cursor: pointer; background: #0056b3; color: white; border: none; border-radius: 4px; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .interactive-area { padding: 15px; border: 2px dashed #ccc; background: #fafafa; display: flex; align-items: center; gap: 15px; }
        input { padding: 8px; flex-grow: 1; font-size: 16px; }
        progress { width: 100%; height: 20px; margin-top: 15px; }
        
        /* CSS Spinner to visually demonstrate UI thread blocking */
        .spinner {
            width: 30px; height: 30px;
            border: 4px solid #ccc;
            border-top-color: #0056b3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <h2>Execution Strategies Demo</h2>

    <div class="interactive-area">
        <div class="spinner"></div>
        <input type="text" placeholder="Type here. If the spinner stops, the UI is blocked.">
    </div>

    <div class="control-panel">
        <label for="strategy-select"><strong>Select Execution Strategy:</strong></label><br>
        <select id="strategy-select">
            <option value="blocking">1. Synchronous (Blocks Main Thread)</option>
            <option value="slicing">2. Time-Slicing (Yields to Main Thread)</option>
            <option value="worker">3. Web Worker (Offloads to OS Thread)</option>
        </select>
        <br>
        <button id="btn-run">Run Heavy Task</button>
    </div>

    <div id="status">Status: Ready</div>
    <progress id="progress-bar" value="0" max="100"></progress>

    <script>
        const btnRun = document.getElementById('btn-run');
        const strategySelect = document.getElementById('strategy-select');
        const statusEl = document.getElementById('status');
        const progressBar = document.getElementById('progress-bar');

        // Total iterations for the heavy task (adjust if your machine runs it too fast/slow)
        const TOTAL_WORK = 5e8; 

        // --- Setup Web Worker via Blob ---
        const workerScript = `
            self.onmessage = function(e) {
                const total = e.data;
                let count = 0;
                for (let i = 0; i < total; i++) { count++; }
                self.postMessage(count);
            };
        `;
        const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
        const worker = new Worker(URL.createObjectURL(workerBlob));

        // --- Execution Controller ---
        btnRun.addEventListener('click', () => {
            const strategy = strategySelect.value;
            
            // Reset UI
            btnRun.disabled = true;
            progressBar.value = 0;
            statusEl.textContent = 'Status: Processing...';
            statusEl.style.color = 'orange';

            // Allow UI to paint the reset state before starting work
            setTimeout(() => {
                if (strategy === 'blocking') {
                    runBlocking();
                } else if (strategy === 'slicing') {
                    runTimeSlicing();
                } else if (strategy === 'worker') {
                    runWebWorker();
                }
            }, 50);
        });

        function completeTask() {
            progressBar.value = 100;
            statusEl.textContent = 'Status: Completed!';
            statusEl.style.color = 'green';
            btnRun.disabled = false;
        }

        // --- Strategy 1: Synchronous Blocking ---
        function runBlocking() {
            let count = 0;
            // This loop monopolizes the Call Stack. The CSS spinner will freeze.
            for (let i = 0; i < TOTAL_WORK; i++) {
                count++;
            }
            completeTask();
        }

        // --- Strategy 2: Time-Slicing (Chunking) ---
        function runTimeSlicing() {
            const chunkSize = 1e7; // Process in chunks
            let current = 0;
            let count = 0;

            function processNextChunk() {
                const end = Math.min(current + chunkSize, TOTAL_WORK);
                
                for (let i = current; i < end; i++) {
                    count++;
                }
                
                current = end;
                progressBar.value = (current / TOTAL_WORK) * 100;

                if (current < TOTAL_WORK) {
                    // Yield control to Event Loop via setTimeout so the browser can render the spinner/input
                    setTimeout(processNextChunk, 0); 
                } else {
                    completeTask();
                }
            }

            processNextChunk();
        }

        // --- Strategy 3: Web Worker ---
        function runWebWorker() {
            // Send instruction to background thread
            worker.postMessage(TOTAL_WORK);
            
            // Artificial progress update since the worker doesn't report progress in this simple demo
            let fakeProgress = 0;
            const progressInterval = setInterval(() => {
                fakeProgress = Math.min(fakeProgress + 5, 95);
                progressBar.value = fakeProgress;
            }, 100);

            worker.onmessage = function(e) {
                clearInterval(progressInterval);
                completeTask();
            };
        }
    </script>
</body>
</html>
